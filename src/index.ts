import 'dotenv/config'

import fastifyStatic from '@fastify/static'
import ngrok from '@ngrok/ngrok'
import fastify from 'fastify'
import { Bot, webhookCallback } from 'grammy'
import * as cron from 'node-cron'
import path from 'path'
import { initDatabase } from './database/connection'
import { dbService } from './database/services'
import { createMessageQueue } from './lib/message-queue'
import { preload } from './lib/preload'
import { getBaseUrl, setServerUrl } from './lib/url'
import { generateImage } from './lib/utils'
import { databaseCommands, databaseComposer } from './onboarding/composer'
import type { DatabaseContext } from './onboarding/types'
import { CronjobService } from './services/cronjob'

export const {
  TELEGRAM_BOT_TOKEN: token,
  TELEGRAM_SECRET_TOKEN: secretToken = String(token || '')
    .split(':')
    .pop() || '',
  PORT = 3501,
} = process.env

const server = fastify()

server.register(fastifyStatic, {
  root: path.join(process.cwd(), 'public'),
  prefix: '/',
})

if (!token) {
  console.error('‚ùå TELEGRAM_BOT_TOKEN is not set')
  console.log('Available environment variables:', Object.keys(process.env).length)
  process.exit(1)
}

const isDevelopment = process.env.NODE_ENV === 'development'
const isProduction = process.env.NODE_ENV === 'production'

console.log('‚úÖ Environment variables loaded successfully')
console.log(`üîß Running in ${isDevelopment ? 'DEVELOPMENT' : isProduction ? 'PRODUCTION' : 'UNKNOWN'} mode`)

export const bot = new Bot<DatabaseContext>(token)

// Create message queue instance
export const messageQueue = createMessageQueue(bot)

// Create cronjob service instance
export const cronjobService = new CronjobService(bot, messageQueue)

bot.api.setMyCommands([...databaseCommands, { command: 'help', description: 'Show help text' }])

bot.use(databaseComposer)

server.post('/api/generate-image', async (request, reply) => {
  try {
    const imageUrl = await generateImage({
      title: 'Hello World!',
      subtitle: 'This is a test image generated by node-html-to-image',
      width: 1000,
      height: 1000,
      backgroundColor: '#4F46E5',
      textColor: '#E0E7FF',
      titleColor: '#FFFFFF',
    })

    const baseUrl = getBaseUrl()
    const fullImageUrl = baseUrl ? `${baseUrl}${imageUrl}` : `http://localhost:3501${imageUrl}`

    reply.send({
      success: true,
      imageUrl: fullImageUrl,
      localPath: imageUrl,
    })
  } catch (error) {
    console.error('Error generating image:', error)
    reply.status(500).send({ error: 'Failed to generate image' })
  }
})

server.get('/health', (request, reply) => {
  reply.send({
    success: true,
    message: 'Bot is running',
  })
})

server.post('/api/send-test-message', async (request, reply) => {
  try {
    await cronjobService.sendTestMessageToAllUsers()
    reply.send({
      success: true,
      message: 'Test message sent to all users',
    })
  } catch (error) {
    console.error('Error sending test message:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to send test message',
    })
  }
})

server.get('/api/queue-status', async (request, reply) => {
  try {
    const status = messageQueue.getQueueStatus()
    reply.send({
      success: true,
      data: {
        queueSize: status.queueSize,
        isProcessing: status.isProcessing,
        nextScheduledMessage: status.nextScheduledMessage,
        estimatedTimeToComplete: status.queueSize > 0 ? Math.ceil(status.queueSize / 25) : 0, // seconds
      },
    })
  } catch (error) {
    console.error('Error getting queue status:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get queue status',
    })
  }
})

server.post('/api/clear-queue', async (request, reply) => {
  try {
    messageQueue.clearQueue()
    reply.send({
      success: true,
      message: 'Message queue cleared',
    })
  } catch (error) {
    console.error('Error clearing queue:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to clear queue',
    })
  }
})

server.post('/api/scan-listings', async (request, reply) => {
  try {
    await cronjobService.scanBountiesAndProjects()
    reply.send({
      success: true,
      message: 'Bounties and projects scanned successfully',
    })
  } catch (error) {
    console.error('Error scanning listings:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to scan listings',
    })
  }
})

server.get('/api/listings-stats', async (request, reply) => {
  try {
    const stats = await dbService.getListingStats()
    reply.send({
      success: true,
      data: stats,
    })
  } catch (error) {
    console.error('Error getting listings stats:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get listings stats',
    })
  }
})

server.get('/api/listings/recent', async (request, reply) => {
  try {
    const limit = parseInt((request.query as any)?.limit) || 5
    const listings = await dbService.getRecentListings(limit)

    const formattedListings = listings.map((listing) => ({
      id: listing.id,
      title: listing.title,
      slug: listing.slug,
      type: listing.type,
      usdValue: listing.usdValue,
      deadline: listing.deadline,
      skills: listing.skills ? JSON.parse(listing.skills) : [],
      mappedSkill: listing.mappedSkill ? JSON.parse(listing.mappedSkill) : [],
      sponsor: listing.sponsor ? JSON.parse(listing.sponsor) : {},
    }))

    reply.send({
      success: true,
      data: formattedListings,
    })
  } catch (error) {
    console.error('Error getting recent listings:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get recent listings',
    })
  }
})

server.post(`/${token}`, webhookCallback(bot, 'fastify', { secretToken: secretToken }))

server.setErrorHandler(async (error) => {
  console.error(error)
})

server.listen({ port: +PORT, host: '0.0.0.0' }, async (error) => {
  if (error) {
    console.error(error)
    process.exit(1)
  }

  await preload()
  console.log('‚úÖ Preloaded assets')

  await initDatabase()
  console.log('‚úÖ Database initialized')

  let webhookUrl: string

  if (isDevelopment) {
    const listener = await ngrok.forward({ addr: +PORT, authtoken_from_env: true })
    webhookUrl = listener.url()!
    setServerUrl(webhookUrl)
    console.log(`üöÄ Bot started at ${webhookUrl} (ngrok)`)
  } else {
    const baseUrl = getBaseUrl()
    if (!baseUrl) {
      console.error('‚ùå Railway URL not found in production environment')
      console.error('Available environment variables:')
      console.error('- RAILWAY_STATIC_URL:', process.env.RAILWAY_STATIC_URL)
      console.error('- RAILWAY_PUBLIC_DOMAIN:', process.env.RAILWAY_PUBLIC_DOMAIN)
      console.error('- PUBLIC_DOMAIN:', process.env.PUBLIC_DOMAIN)
      console.error('- RAILWAY_PROJECT_ID:', process.env.RAILWAY_PROJECT_ID)
      console.error('- RAILWAY_SERVICE_ID:', process.env.RAILWAY_SERVICE_ID)
      process.exit(1)
    }
    webhookUrl = baseUrl
    console.log(`üöÄ Bot started at ${webhookUrl} (Railway) with port ${PORT}`)
  }

  if (isProduction) {
    console.log('‚è≥ Waiting for Railway service to be fully accessible...')
    await new Promise((resolve) => setTimeout(resolve, 5000)) // Wait 5 seconds
  }

  await setupWebhookWithRetry(webhookUrl, secretToken)

  // Set up cronjob to scan bounties and projects every 5 minutes
  cron.schedule('*/2 * * * *', () => cronjobService.scanBountiesAndProjects(), {
    timezone: 'UTC',
  })

  console.log('‚è∞ Cronjob scheduled: Bounties and projects will be scanned every 5 minutes')
})

async function setupWebhookWithRetry(webhookUrl: string, secretToken: string, maxRetries = 3, delayMs = 10000) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üîÑ Setting webhook (attempt ${attempt}/${maxRetries}): ${webhookUrl}/${token}`)
      await bot.api.setWebhook(`${webhookUrl}/${token}`, { secret_token: secretToken })
      console.log('‚úÖ Webhook set successfully!')
      return
    } catch (error) {
      console.error(`‚ùå Webhook setup failed (attempt ${attempt}/${maxRetries}):`, error)

      if (attempt === maxRetries) {
        console.error('üö® Failed to set webhook after all retries. The bot may not receive updates.')
        console.error('üí° Check if your Railway domain is accessible and Telegram can reach it.')
        return
      }

      console.log(`‚è≥ Waiting ${delayMs / 1000}s before retry...`)
      await new Promise((resolve) => setTimeout(resolve, delayMs))
    }
  }
}
