import 'dotenv/config'

import type { Context, SessionFlavor } from 'grammy'
import { Bot, webhookCallback } from 'grammy'

import { commands as onboardingCommands, composer as onboardingComposer } from './onboarding/composer'
import type { OnboardingSessionData } from './onboarding/types'

import { getBaseUrl, setServerUrl, getImageUrl } from './lib/url'
import { generateImage, generateListingThumbnail } from './lib/utils'
import { preload } from './lib/preload'
// import { initDatabase } from './database/connection'

import fastifyStatic from '@fastify/static'
import ngrok from '@ngrok/ngrok'
import fastify from 'fastify'
import path from 'path'
import { initDatabase } from './database/connection'
import { dbService } from './database/services'
import * as cron from 'node-cron'

type MyContext = Context & SessionFlavor<OnboardingSessionData>

export const {
  TELEGRAM_BOT_TOKEN: token,
  TELEGRAM_SECRET_TOKEN: secretToken = String(token || '')
    .split(':')
    .pop() || '',
  PORT = 3501,
} = process.env

const server = fastify()

server.register(fastifyStatic, {
  root: path.join(process.cwd(), 'public'),
  prefix: '/',
})

if (!token) {
  console.error('‚ùå TELEGRAM_BOT_TOKEN is not set')
  console.log('Available environment variables:', Object.keys(process.env).length)
  process.exit(1)
}

const isDevelopment = process.env.NODE_ENV === 'development'
const isProduction = process.env.NODE_ENV === 'production'

console.log('‚úÖ Environment variables loaded successfully')
console.log(`üîß Running in ${isDevelopment ? 'DEVELOPMENT' : isProduction ? 'PRODUCTION' : 'UNKNOWN'} mode`)

export const bot = new Bot<MyContext>(token)

bot.api.setMyCommands([...onboardingCommands, { command: 'help', description: 'Show help text' }])

bot.use(onboardingComposer)

server.post('/api/generate-image', async (request, reply) => {
  try {
    const imageUrl = await generateImage({
      title: 'Hello World!',
      subtitle: 'This is a test image generated by node-html-to-image',
      width: 1000,
      height: 1000,
      backgroundColor: '#4F46E5',
      textColor: '#E0E7FF',
      titleColor: '#FFFFFF',
    })

    const baseUrl = getBaseUrl()
    const fullImageUrl = baseUrl ? `${baseUrl}${imageUrl}` : `http://localhost:3501${imageUrl}`

    reply.send({
      success: true,
      imageUrl: fullImageUrl,
      localPath: imageUrl,
    })
  } catch (error) {
    console.error('Error generating image:', error)
    reply.status(500).send({ error: 'Failed to generate image' })
  }
})

server.get('/health', (request, reply) => {
  reply.send({
    success: true,
    message: 'Bot is running',
  })
})

server.post('/api/send-test-message', async (request, reply) => {
  try {
    await sendTestMessageToAllUsers()
    reply.send({
      success: true,
      message: 'Test message sent to all users',
    })
  } catch (error) {
    console.error('Error sending test message:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to send test message',
    })
  }
})

server.post(`/${token}`, webhookCallback(bot, 'fastify', { secretToken: secretToken }))

server.setErrorHandler(async (error) => {
  console.error(error)
})

// Cronjob function to send test message to all users
async function sendTestMessageToAllUsers() {
  try {
    console.log('üîÑ Starting cronjob: sending test message to all users...')

    // Get all users from database
    const users = await dbService.getAllUsers()

    if (users.length === 0) {
      console.log('üì≠ No users found in database')
      return
    }

    console.log(`üì® Found ${users.length} users, sending test message...`)

    // Generate thumbnail for the test message
    const imageUrl = await generateListingThumbnail('Build your App with AI on Solana: AImpact Beta Challenge')

    // Send message to each user
    let successCount = 0
    let errorCount = 0

    for (const user of users) {
      try {
        await bot.api.sendPhoto(user.telegramId, getImageUrl(imageUrl), {
          caption: `**Kumeka Team** is sponsoring this listing!

Build no-code Solana apps with AImpact for a chance to win up to $2000 USDC and shape the future of AI-powered development.`,
          parse_mode: 'Markdown',
          reply_markup: {
            inline_keyboard: [
              [
                {
                  text: 'Remind me every 12 hours',
                  callback_data: 'remind_me',
                },
                {
                  text: 'Join',
                  url: 'https://earn.superteam.fun/listing/aimpact-beta-challenge/?utm_source=telegrambot',
                },
              ],
            ],
          },
        })
        successCount++
      } catch (error) {
        console.error(`‚ùå Failed to send message to user ${user.telegramId}:`, error)
        errorCount++
      }
    }

    console.log(`‚úÖ Cronjob completed: ${successCount} messages sent successfully, ${errorCount} errors`)
  } catch (error) {
    console.error('‚ùå Cronjob error:', error)
  }
}

server.listen({ port: +PORT, host: '0.0.0.0' }, async (error) => {
  if (error) {
    console.error(error)
    process.exit(1)
  }

  await preload()
  console.log('‚úÖ Preloaded assets')

  await initDatabase()
  console.log('‚úÖ Database initialized')

  let webhookUrl: string

  if (isDevelopment) {
    const listener = await ngrok.forward({ addr: +PORT, authtoken_from_env: true })
    webhookUrl = listener.url()!
    setServerUrl(webhookUrl)
    console.log(`üöÄ Bot started at ${webhookUrl} (ngrok)`)
  } else {
    const baseUrl = getBaseUrl()
    if (!baseUrl) {
      console.error('‚ùå Railway URL not found in production environment')
      console.error('Available environment variables:')
      console.error('- RAILWAY_STATIC_URL:', process.env.RAILWAY_STATIC_URL)
      console.error('- RAILWAY_PUBLIC_DOMAIN:', process.env.RAILWAY_PUBLIC_DOMAIN)
      console.error('- PUBLIC_DOMAIN:', process.env.PUBLIC_DOMAIN)
      console.error('- RAILWAY_PROJECT_ID:', process.env.RAILWAY_PROJECT_ID)
      console.error('- RAILWAY_SERVICE_ID:', process.env.RAILWAY_SERVICE_ID)
      process.exit(1)
    }
    webhookUrl = baseUrl
    console.log(`üöÄ Bot started at ${webhookUrl} (Railway) with port ${PORT}`)
  }

  if (isProduction) {
    console.log('‚è≥ Waiting for Railway service to be fully accessible...')
    await new Promise((resolve) => setTimeout(resolve, 5000)) // Wait 5 seconds
  }

  await setupWebhookWithRetry(webhookUrl, secretToken)

  // Set up cronjob to send test message every 5 minutes
  cron.schedule('*/10 * * * * *', sendTestMessageToAllUsers, {
    timezone: 'UTC',
  })

  console.log('‚è∞ Cronjob scheduled: Test message will be sent to all users every 5 minutes')
})

async function setupWebhookWithRetry(webhookUrl: string, secretToken: string, maxRetries = 3, delayMs = 10000) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üîÑ Setting webhook (attempt ${attempt}/${maxRetries}): ${webhookUrl}/${token}`)
      await bot.api.setWebhook(`${webhookUrl}/${token}`, { secret_token: secretToken })
      console.log('‚úÖ Webhook set successfully!')
      return
    } catch (error) {
      console.error(`‚ùå Webhook setup failed (attempt ${attempt}/${maxRetries}):`, error)

      if (attempt === maxRetries) {
        console.error('üö® Failed to set webhook after all retries. The bot may not receive updates.')
        console.error('üí° Check if your Railway domain is accessible and Telegram can reach it.')
        return
      }

      console.log(`‚è≥ Waiting ${delayMs / 1000}s before retry...`)
      await new Promise((resolve) => setTimeout(resolve, delayMs))
    }
  }
}
