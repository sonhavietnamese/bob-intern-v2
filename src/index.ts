import 'dotenv/config'

import fastifyStatic from '@fastify/static'
import ngrok from '@ngrok/ngrok'
import fastify from 'fastify'
import { Bot, webhookCallback } from 'grammy'
import * as cron from 'node-cron'
import path from 'path'
import { initDatabase } from './database/connection'
import { dbService } from './database/services'
import { createMessageQueue } from './lib/message-queue'
import { preload } from './lib/preload'
import { getBaseUrl, setServerUrl } from './lib/url'
import { generateImage } from './lib/utils'
import { databaseCommands, databaseComposer } from './onboarding/composer'
import type { DatabaseContext } from './onboarding/types'
import { CronjobService } from './services/cronjob'
import { TIMING_CONFIG } from './config'

export const {
  TELEGRAM_BOT_TOKEN: token,
  TELEGRAM_SECRET_TOKEN: secretToken = String(token || '')
    .split(':')
    .pop() || '',
  PORT = 3501,
} = process.env

const server = fastify()

server.register(fastifyStatic, {
  root: path.join(process.cwd(), 'public'),
  prefix: '/',
})

if (!token) {
  console.error('‚ùå TELEGRAM_BOT_TOKEN is not set')
  console.log('Available environment variables:', Object.keys(process.env).length)
  process.exit(1)
}

const isDevelopment = process.env.NODE_ENV === 'development'
const isProduction = process.env.NODE_ENV === 'production'

console.log('‚úÖ Environment variables loaded successfully')
console.log(`üîß Running in ${isDevelopment ? 'DEVELOPMENT' : isProduction ? 'PRODUCTION' : 'UNKNOWN'} mode`)

export const bot = new Bot<DatabaseContext>(token)

// Create message queue instance
export const messageQueue = createMessageQueue(bot)

// Create cronjob service instance
export const cronjobService = new CronjobService(bot, messageQueue)

bot.api.setMyCommands([...databaseCommands, { command: 'help', description: 'Show help text' }])

bot.use(databaseComposer)

server.post('/api/generate-image', async (request, reply) => {
  try {
    const imageUrl = await generateImage({
      title: 'Hello World!',
      subtitle: 'This is a test image generated by node-html-to-image',
      width: 1000,
      height: 1000,
      backgroundColor: '#4F46E5',
      textColor: '#E0E7FF',
      titleColor: '#FFFFFF',
    })

    const baseUrl = getBaseUrl()
    const fullImageUrl = baseUrl ? `${baseUrl}${imageUrl}` : `http://localhost:3501${imageUrl}`

    reply.send({
      success: true,
      imageUrl: fullImageUrl,
      localPath: imageUrl,
    })
  } catch (error) {
    console.error('Error generating image:', error)
    reply.status(500).send({ error: 'Failed to generate image' })
  }
})

server.get('/health', (request, reply) => {
  reply.send({
    success: true,
    message: 'Bot is running',
  })
})

server.post('/api/send-test-message', async (request, reply) => {
  try {
    await cronjobService.sendTestMessageToAllUsers()
    reply.send({
      success: true,
      message: 'Test message sent to all users',
    })
  } catch (error) {
    console.error('Error sending test message:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to send test message',
    })
  }
})

server.get('/api/queue-status', async (request, reply) => {
  try {
    const status = messageQueue.getQueueStatus()
    reply.send({
      success: true,
      data: {
        queueSize: status.queueSize,
        isProcessing: status.isProcessing,
        nextScheduledMessage: status.nextScheduledMessage,
        estimatedTimeToComplete: status.queueSize > 0 ? Math.ceil(status.queueSize / TIMING_CONFIG.MESSAGE_QUEUE.ESTIMATED_MESSAGES_PER_SECOND) : 0, // seconds
      },
    })
  } catch (error) {
    console.error('Error getting queue status:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get queue status',
    })
  }
})

server.post('/api/clear-queue', async (request, reply) => {
  try {
    messageQueue.clearQueue()
    reply.send({
      success: true,
      message: 'Message queue cleared',
    })
  } catch (error) {
    console.error('Error clearing queue:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to clear queue',
    })
  }
})

server.post('/api/scan-listings', async (request, reply) => {
  try {
    await cronjobService.scanBountiesAndProjects()
    reply.send({
      success: true,
      message: 'Bounties and projects scanned successfully',
    })
  } catch (error) {
    console.error('Error scanning listings:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to scan listings',
    })
  }
})

server.get('/api/listings-stats', async (request, reply) => {
  try {
    const stats = await dbService.getListingStats()
    reply.send({
      success: true,
      data: stats,
    })
  } catch (error) {
    console.error('Error getting listings stats:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get listings stats',
    })
  }
})

server.get('/api/listings/recent', async (request, reply) => {
  try {
    const limit = parseInt((request.query as any)?.limit) || 5
    const listings = await dbService.getRecentListings(limit)

    const formattedListings = listings.map((listing) => ({
      id: listing.id,
      title: listing.title,
      slug: listing.slug,
      type: listing.type,
      usdValue: listing.usdValue,
      deadline: listing.deadline,
      skills: listing.skills ? JSON.parse(listing.skills) : [],
      mappedSkill: listing.mappedSkill ? JSON.parse(listing.mappedSkill) : [],
      sponsor: listing.sponsor ? JSON.parse(listing.sponsor) : {},
    }))

    reply.send({
      success: true,
      data: formattedListings,
    })
  } catch (error) {
    console.error('Error getting recent listings:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get recent listings',
    })
  }
})

server.get('/api/matching-stats', async (request, reply) => {
  try {
    const stats = await dbService.getMatchingStats()
    reply.send({
      success: true,
      data: stats,
    })
  } catch (error) {
    console.error('Error getting matching stats:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get matching stats',
    })
  }
})

server.post('/api/test-skill-matching', async (request, reply) => {
  try {
    await cronjobService.processSkillMatchingCronjob()
    const stats = await dbService.getMatchingStats()
    reply.send({
      success: true,
      message: 'Skill matching process completed successfully',
      stats,
    })
  } catch (error) {
    console.error('Error in test skill matching:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to process skill matching',
    })
  }
})

server.get('/api/recent-matches', async (request, reply) => {
  try {
    const matches = await dbService.getActiveUserListingMatches()
    const formattedMatches = matches.slice(0, 10).map((match) => ({
      id: match.id,
      userId: match.userId,
      userName: match.user.userName,
      listingId: match.listingId,
      listingTitle: match.listing.title,
      listingType: match.listing.type,
      matchScore: match.matchScore,
      createdAt: match.createdAt,
    }))

    reply.send({
      success: true,
      data: formattedMatches,
    })
  } catch (error) {
    console.error('Error getting recent matches:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get recent matches',
    })
  }
})

server.post('/api/clean-duplicates', async (request, reply) => {
  try {
    const deletedCount = await dbService.removeDuplicateMatches()
    reply.send({
      success: true,
      message: `Cleaned up ${deletedCount} duplicate matches`,
      deletedCount,
    })
  } catch (error) {
    console.error('Error cleaning duplicates:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to clean duplicates',
    })
  }
})

server.post('/api/clear-notifications', async (request, reply) => {
  try {
    // Clear all notifications to test fresh sends
    const result = await dbService.clearAllNotifications()
    reply.send({
      success: true,
      message: `Cleared ${result} notifications for testing`,
      clearedCount: result,
    })
  } catch (error) {
    console.error('Error clearing notifications:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to clear notifications',
    })
  }
})

// Reminder API endpoints
server.get('/api/reminder-stats', async (request, reply) => {
  try {
    const stats = await dbService.getReminderStats()
    reply.send({
      success: true,
      data: stats,
    })
  } catch (error) {
    console.error('Error getting reminder stats:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get reminder stats',
    })
  }
})

server.get('/api/active-reminders', async (request, reply) => {
  try {
    const reminders = await dbService.getActiveReminders()
    const formattedReminders = reminders.slice(0, 10).map((reminder) => ({
      id: reminder.id,
      userId: reminder.userId,
      userName: reminder.user.userName,
      listingId: reminder.listingId,
      listingTitle: reminder.listing.title,
      listingType: reminder.listing.type,
      intervalHours: reminder.intervalHours,
      lastRemindedAt: reminder.lastRemindedAt,
      createdAt: reminder.createdAt,
    }))

    reply.send({
      success: true,
      data: formattedReminders,
    })
  } catch (error) {
    console.error('Error getting active reminders:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get active reminders',
    })
  }
})

server.post('/api/test-reminders', async (request, reply) => {
  try {
    await cronjobService.sendReminders()
    const stats = await dbService.getReminderStats()
    reply.send({
      success: true,
      message: 'Reminder sending process completed successfully',
      stats,
    })
  } catch (error) {
    console.error('Error in test reminders:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to process reminders',
    })
  }
})

server.get('/api/reminders-ready', async (request, reply) => {
  try {
    const readyReminders = await dbService.getRemindersReadyToSend()
    const formattedReminders = readyReminders.map((reminder) => ({
      id: reminder.id,
      userId: reminder.userId,
      userName: reminder.user.userName,
      listingId: reminder.listingId,
      listingTitle: reminder.listing.title,
      intervalHours: reminder.intervalHours,
      lastRemindedAt: reminder.lastRemindedAt,
      timeSinceLastReminder: reminder.lastRemindedAt ? Math.round((Date.now() - reminder.lastRemindedAt.getTime()) / (1000 * 60 * 60)) : null,
    }))

    reply.send({
      success: true,
      data: formattedReminders,
    })
  } catch (error) {
    console.error('Error getting ready reminders:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get ready reminders',
    })
  }
})

server.post(`/${token}`, webhookCallback(bot, 'fastify', { secretToken: secretToken }))

server.setErrorHandler(async (error) => {
  console.error(error)
})

server.listen({ port: +PORT, host: '0.0.0.0' }, async (error) => {
  if (error) {
    console.error(error)
    process.exit(1)
  }

  await preload()
  console.log('‚úÖ Preloaded assets')

  await initDatabase()
  console.log('‚úÖ Database initialized')

  let webhookUrl: string

  if (isDevelopment) {
    const listener = await ngrok.forward({ addr: +PORT, authtoken_from_env: true })
    webhookUrl = listener.url()!
    setServerUrl(webhookUrl)
    console.log(`üöÄ Bot started at ${webhookUrl} (ngrok)`)
  } else {
    const baseUrl = getBaseUrl()
    if (!baseUrl) {
      console.error('‚ùå Railway URL not found in production environment')
      console.error('Available environment variables:')
      console.error('- RAILWAY_STATIC_URL:', process.env.RAILWAY_STATIC_URL)
      console.error('- RAILWAY_PUBLIC_DOMAIN:', process.env.RAILWAY_PUBLIC_DOMAIN)
      console.error('- PUBLIC_DOMAIN:', process.env.PUBLIC_DOMAIN)
      console.error('- RAILWAY_PROJECT_ID:', process.env.RAILWAY_PROJECT_ID)
      console.error('- RAILWAY_SERVICE_ID:', process.env.RAILWAY_SERVICE_ID)
      process.exit(1)
    }
    webhookUrl = baseUrl
    console.log(`üöÄ Bot started at ${webhookUrl} (Railway) with port ${PORT}`)
  }

  if (isProduction) {
    console.log('‚è≥ Waiting for Railway service to be fully accessible...')
    await new Promise((resolve) => setTimeout(resolve, TIMING_CONFIG.WEBHOOK.PRODUCTION_STARTUP_DELAY_MS))
  }

  await setupWebhookWithRetry(webhookUrl, secretToken)

  // Set up cronjob to scan bounties and projects
  cron.schedule(TIMING_CONFIG.CRONJOBS.LISTINGS_SCAN, () => cronjobService.scanBountiesAndProjects(), {
    timezone: 'UTC',
  })

  // Set up skill matching cronjob: notifications and reminders
  cron.schedule(TIMING_CONFIG.CRONJOBS.NOTIFICATIONS, () => cronjobService.processSkillMatchingCronjob(), {
    timezone: 'UTC',
  })

  console.log(`‚è∞ Cronjob scheduled: Bounties and projects will be scanned on schedule: ${TIMING_CONFIG.CRONJOBS.LISTINGS_SCAN}`)
  console.log(`‚è∞ Skill matching cronjob scheduled: ${TIMING_CONFIG.ENVIRONMENT_DIFFERENCES.NOTIFICATION_FREQUENCY}`)
})

async function setupWebhookWithRetry(
  webhookUrl: string,
  secretToken: string,
  maxRetries = TIMING_CONFIG.WEBHOOK.MAX_RETRIES,
  delayMs = TIMING_CONFIG.WEBHOOK.RETRY_DELAY_MS,
) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üîÑ Setting webhook (attempt ${attempt}/${maxRetries}): ${webhookUrl}/${token}`)
      await bot.api.setWebhook(`${webhookUrl}/${token}`, { secret_token: secretToken })
      console.log('‚úÖ Webhook set successfully!')
      return
    } catch (error) {
      console.error(`‚ùå Webhook setup failed (attempt ${attempt}/${maxRetries}):`, error)

      if (attempt === maxRetries) {
        console.error('üö® Failed to set webhook after all retries. The bot may not receive updates.')
        console.error('üí° Check if your Railway domain is accessible and Telegram can reach it.')
        return
      }

      console.log(`‚è≥ Waiting ${delayMs / 1000}s before retry...`)
      await new Promise((resolve) => setTimeout(resolve, delayMs))
    }
  }
}
