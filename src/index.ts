import 'dotenv/config'

import { Bot, webhookCallback } from 'grammy'
import { databaseCommands, databaseComposer } from './onboarding/composer'
import type { DatabaseContext } from './onboarding/types'
import { createMessageQueue } from './lib/message-queue'
import { preload } from './lib/preload'
import { getBaseUrl, getImageUrl, setServerUrl } from './lib/url'
import { generateImage, generateListingThumbnail } from './lib/utils'
import fastifyStatic from '@fastify/static'
import ngrok from '@ngrok/ngrok'
import fastify from 'fastify'
import * as cron from 'node-cron'
import path from 'path'
import { initDatabase } from './database/connection'
import { dbService } from './database/services'

export const {
  TELEGRAM_BOT_TOKEN: token,
  TELEGRAM_SECRET_TOKEN: secretToken = String(token || '')
    .split(':')
    .pop() || '',
  PORT = 3501,
} = process.env

const server = fastify()

server.register(fastifyStatic, {
  root: path.join(process.cwd(), 'public'),
  prefix: '/',
})

if (!token) {
  console.error('‚ùå TELEGRAM_BOT_TOKEN is not set')
  console.log('Available environment variables:', Object.keys(process.env).length)
  process.exit(1)
}

const isDevelopment = process.env.NODE_ENV === 'development'
const isProduction = process.env.NODE_ENV === 'production'

console.log('‚úÖ Environment variables loaded successfully')
console.log(`üîß Running in ${isDevelopment ? 'DEVELOPMENT' : isProduction ? 'PRODUCTION' : 'UNKNOWN'} mode`)

export const bot = new Bot<DatabaseContext>(token)

// Create message queue instance
export const messageQueue = createMessageQueue(bot)

bot.api.setMyCommands([...databaseCommands, { command: 'help', description: 'Show help text' }])

bot.use(databaseComposer)

server.post('/api/generate-image', async (request, reply) => {
  try {
    const imageUrl = await generateImage({
      title: 'Hello World!',
      subtitle: 'This is a test image generated by node-html-to-image',
      width: 1000,
      height: 1000,
      backgroundColor: '#4F46E5',
      textColor: '#E0E7FF',
      titleColor: '#FFFFFF',
    })

    const baseUrl = getBaseUrl()
    const fullImageUrl = baseUrl ? `${baseUrl}${imageUrl}` : `http://localhost:3501${imageUrl}`

    reply.send({
      success: true,
      imageUrl: fullImageUrl,
      localPath: imageUrl,
    })
  } catch (error) {
    console.error('Error generating image:', error)
    reply.status(500).send({ error: 'Failed to generate image' })
  }
})

server.get('/health', (request, reply) => {
  reply.send({
    success: true,
    message: 'Bot is running',
  })
})

server.post('/api/send-test-message', async (request, reply) => {
  try {
    await sendTestMessageToAllUsers()
    reply.send({
      success: true,
      message: 'Test message sent to all users',
    })
  } catch (error) {
    console.error('Error sending test message:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to send test message',
    })
  }
})

server.get('/api/queue-status', async (request, reply) => {
  try {
    const status = messageQueue.getQueueStatus()
    reply.send({
      success: true,
      data: {
        queueSize: status.queueSize,
        isProcessing: status.isProcessing,
        nextScheduledMessage: status.nextScheduledMessage,
        estimatedTimeToComplete: status.queueSize > 0 ? Math.ceil(status.queueSize / 25) : 0, // seconds
      },
    })
  } catch (error) {
    console.error('Error getting queue status:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to get queue status',
    })
  }
})

server.post('/api/clear-queue', async (request, reply) => {
  try {
    messageQueue.clearQueue()
    reply.send({
      success: true,
      message: 'Message queue cleared',
    })
  } catch (error) {
    console.error('Error clearing queue:', error)
    reply.status(500).send({
      success: false,
      error: 'Failed to clear queue',
    })
  }
})

server.post(`/${token}`, webhookCallback(bot, 'fastify', { secretToken: secretToken }))

server.setErrorHandler(async (error) => {
  console.error(error)
})

// Cronjob function to send test message to all users
async function sendTestMessageToAllUsers() {
  try {
    console.log('üîÑ Starting cronjob: sending test message to all users...')

    // Get all users from database
    const users = await dbService.getAllUsers()

    if (users.length === 0) {
      console.log('üì≠ No users found in database')
      return
    }

    console.log(`üì® Found ${users.length} users, adding to message queue...`)

    // Generate thumbnail for the test message
    const imageUrl = await generateListingThumbnail('Build your App with AI on Solana: AImpact Beta Challenge')

    // Prepare message data
    const messageOptions = {
      caption: `**Kumeka Team** is sponsoring this listing!

Build no-code Solana apps with AImpact for a chance to win up to $2000 USDC and shape the future of AI-powered development.`,
      parse_mode: 'Markdown' as const,
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: 'Remind me every 12 hours',
              callback_data: 'remind_me',
            },
            {
              text: 'Join',
              url: 'https://earn.superteam.fun/listing/aimpact-beta-challenge/?utm_source=telegrambot',
            },
          ],
        ],
      },
    }

    // Add all messages to the queue
    const queuedMessages = users.map((user) => ({
      userId: user.id.toString(),
      telegramId: user.telegramId,
      messageData: {
        type: 'photo' as const,
        content: getImageUrl(imageUrl),
        options: messageOptions,
      },
      maxRetries: 3,
      scheduledAt: new Date(), // Send immediately
    }))

    messageQueue.addBulkMessages(queuedMessages)

    const queueStatus = messageQueue.getQueueStatus()
    console.log(`‚úÖ Added ${users.length} messages to queue. Queue size: ${queueStatus.queueSize}`)
  } catch (error) {
    console.error('‚ùå Cronjob error:', error)
  }
}

server.listen({ port: +PORT, host: '0.0.0.0' }, async (error) => {
  if (error) {
    console.error(error)
    process.exit(1)
  }

  await preload()
  console.log('‚úÖ Preloaded assets')

  await initDatabase()
  console.log('‚úÖ Database initialized')

  let webhookUrl: string

  if (isDevelopment) {
    const listener = await ngrok.forward({ addr: +PORT, authtoken_from_env: true })
    webhookUrl = listener.url()!
    setServerUrl(webhookUrl)
    console.log(`üöÄ Bot started at ${webhookUrl} (ngrok)`)
  } else {
    const baseUrl = getBaseUrl()
    if (!baseUrl) {
      console.error('‚ùå Railway URL not found in production environment')
      console.error('Available environment variables:')
      console.error('- RAILWAY_STATIC_URL:', process.env.RAILWAY_STATIC_URL)
      console.error('- RAILWAY_PUBLIC_DOMAIN:', process.env.RAILWAY_PUBLIC_DOMAIN)
      console.error('- PUBLIC_DOMAIN:', process.env.PUBLIC_DOMAIN)
      console.error('- RAILWAY_PROJECT_ID:', process.env.RAILWAY_PROJECT_ID)
      console.error('- RAILWAY_SERVICE_ID:', process.env.RAILWAY_SERVICE_ID)
      process.exit(1)
    }
    webhookUrl = baseUrl
    console.log(`üöÄ Bot started at ${webhookUrl} (Railway) with port ${PORT}`)
  }

  if (isProduction) {
    console.log('‚è≥ Waiting for Railway service to be fully accessible...')
    await new Promise((resolve) => setTimeout(resolve, 5000)) // Wait 5 seconds
  }

  await setupWebhookWithRetry(webhookUrl, secretToken)

  // Set up cronjob to send test message every 5 minutes
  cron.schedule('*/5 * * * *', sendTestMessageToAllUsers, {
    timezone: 'UTC',
  })

  console.log('‚è∞ Cronjob scheduled: Test message will be sent to all users every 5 minutes')
})

async function setupWebhookWithRetry(webhookUrl: string, secretToken: string, maxRetries = 3, delayMs = 10000) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üîÑ Setting webhook (attempt ${attempt}/${maxRetries}): ${webhookUrl}/${token}`)
      await bot.api.setWebhook(`${webhookUrl}/${token}`, { secret_token: secretToken })
      console.log('‚úÖ Webhook set successfully!')
      return
    } catch (error) {
      console.error(`‚ùå Webhook setup failed (attempt ${attempt}/${maxRetries}):`, error)

      if (attempt === maxRetries) {
        console.error('üö® Failed to set webhook after all retries. The bot may not receive updates.')
        console.error('üí° Check if your Railway domain is accessible and Telegram can reach it.')
        return
      }

      console.log(`‚è≥ Waiting ${delayMs / 1000}s before retry...`)
      await new Promise((resolve) => setTimeout(resolve, delayMs))
    }
  }
}
